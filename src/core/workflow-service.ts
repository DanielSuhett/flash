import * as core from '@actions/core';
import { ActionConfig, CodeReviewResult, PullRequestInfo } from '../types/index.js';
import { GitHubService } from '../github/github-service.js';
import { CodeIndexer } from '../indexing/indexer.js';
import { LLMService } from '../llm/llm-service.js';

export class WorkflowService {
  private config: ActionConfig;
  private githubService: GitHubService;
  private codeIndexer: CodeIndexer;
  private llmService: LLMService;

  constructor(config: ActionConfig) {
    this.config = config;
    this.githubService = new GitHubService(config.githubToken);
    this.codeIndexer = new CodeIndexer(config.githubToken);
    this.llmService = new LLMService(config.llmApiKey, config.llmEndpoint);
  }

  async processReview(owner: string, repo: string, prNumber: number): Promise<void> {
    try {
      core.info(`Starting review for PR #${prNumber} in ${owner}/${repo}`);
      
      const pullRequestInfo = await this.githubService.getPullRequestInfo(owner, repo, prNumber);
      core.info(`Analyzing PR: ${pullRequestInfo.title}`);
      
      const prWithContents = await this.githubService.loadFileContents(pullRequestInfo);
      core.info(`Loaded content for ${prWithContents.files.length} changed files`);
      
      const changedFiles = pullRequestInfo.files.map(file => file.filename);
      
      core.info('Indexing codebase structure...');
      const indexedCodebase = await this.codeIndexer.indexCodebase(
        owner,
        repo,
        pullRequestInfo.baseBranch,
        changedFiles
      );
      
      core.info('Performing code review with Gemini...');
      const reviewResult = await this.llmService.performCodeReview({
        indexedCodebase,
        pullRequest: prWithContents
      });
      
      core.info('Posting review results...');
      await this.postReviewComment(pullRequestInfo, reviewResult);
      
      if (this.config.autoApprove && reviewResult.approvalRecommended) {
        core.info('Auto-approval is enabled and recommended by LLM. Processing...');
        await this.approveAndMergePR(pullRequestInfo);
      }
      
      core.info('Code review completed successfully');
    } catch (error) {
      core.error(`Error during review process: ${error}`);
      throw error;
    }
  }

  private async postReviewComment(
    pullRequestInfo: PullRequestInfo, 
    reviewResult: CodeReviewResult
  ): Promise<void> {
    const { owner, repo, prNumber } = pullRequestInfo;
    
    let commentBody = `# TypeScript Deep Code Review\n\n`;
    
    commentBody += `## Summary\n${reviewResult.summary}\n\n`;
    commentBody += `**Overall Quality Score**: ${reviewResult.overallQuality}/100\n`;
    commentBody += `**Recommendation**: ${reviewResult.approvalRecommended ? '‚úÖ Approve' : '‚ùå Needs Improvement'}\n\n`;
    
    if (reviewResult.comments.length > 0) {
      commentBody += `## Detailed Feedback\n\n`;
      
      for (const comment of reviewResult.comments) {
        const locationInfo = comment.startLine 
          ? `lines ${comment.startLine}-${comment.endLine || comment.startLine}` 
          : '';
          
        const severity = {
          'error': 'üî¥ ERROR',
          'warning': 'üü† WARNING',
          'info': 'üîµ INFO',
          'suggestion': 'üí° SUGGESTION'
        }[comment.severity];
        
        commentBody += `### ${severity}: ${comment.file} ${locationInfo}\n`;
        commentBody += `**Category**: ${comment.category}\n\n`;
        commentBody += `${comment.message}\n\n`;
      }
    }
    
    commentBody += `---\n*This review was automatically generated by the TypeScript Deep Code Review GitHub Action powered by Google's Gemini.*`;
    
    await this.githubService.createComment(owner, repo, prNumber, commentBody);
  }

  private async approveAndMergePR(pullRequestInfo: PullRequestInfo): Promise<void> {
    const { owner, repo, prNumber } = pullRequestInfo;
    
    const approvalMessage = 'Automatically approving based on code review results.';
    
    try {
      await this.githubService.createReview(
        owner, 
        repo, 
        prNumber, 
        'HEAD', 
        approvalMessage, 
        'APPROVE'
      );
      
      core.info('PR approved successfully');
      
      if (this.config.autoMerge) {
        const merged = await this.githubService.mergePullRequest(owner, repo, prNumber);
        
        if (merged) {
          core.info('PR merged successfully');
        } else {
          core.warning('PR was approved but could not be automatically merged');
          await this.githubService.createComment(
            owner, 
            repo, 
            prNumber, 
            '‚ö†Ô∏è PR was approved but could not be automatically merged. Please resolve any conflicts and merge manually.'
          );
        }
      }
    } catch (error) {
      core.error(`Error during approval/merge: ${error}`);
      
      await this.githubService.createComment(
        owner, 
        repo, 
        prNumber, 
        '‚ö†Ô∏è An error occurred while trying to approve/merge the PR automatically.'
      );
    }
  }
} 